# 3DSurvival
3D Survival

## Q1 분석 문제

- 입문 주차와 비교해서 입력 받는 방식의 차이와 공통점을 비교해보세요.
  - 입문 주차와 숙련 주차에서 Move와 Look 입력 받는 방식의 공통점은 입력 값에 대해 x,y 좌표만 받는 다는 것입니다.
차이점은 동일한 x,y 좌표를 가지고 캐릭터가 3D 좌표 평면에서 움직이느냐 2D 좌표 평면에서 움직이느냐 차이인데,
3D 인 경우 캐릭터의 진행방향이 위쪽이 아닌 정면을 바라보고 움직여야 하기 때문에 z 축을 방향으로 움직여야합니다.
2D 인 경우 캐릭터의 진행방향이 상하좌우로만 이동하기 때문에 입력 받은 값 그대로 사용하여 캐릭터를 움직여도 무방합니다.

- `CharacterManager`와 `Player`의 역할에 대해 고민해보세요.
  - 현재 프로젝트에서 CharacterManager는 Player와 연관성이 없는 UI와 같은 객체들과의 상호작용을 위해 의존성 높여 주는 역할을 하고 있습니다.
Player는 실제 캐릭터를 조작하고 움직이며 그 외 다른 객체와 상호작용 할 수 있는 역할을 수행 하고 있습니다.

- 핵심 로직을 분석해보세요 (`Move`, `CameraLook`, `IsGrounded`)
  - Move 함수에서는 입력 받은 key의 x,y 방향 좌표를 받아 캐릭터의 이동 방향을 계산하고 캐릭터의 속도를 곱해주고 y값은 기존 y값과 동일하게 하여 위로 향하지 않게 고정해준 후 구해진 이동 방향을 rigidbody의 velocity에 대입합니다.
CameraLook 함수에서는 마우스 위치의 y 축 값을 lookSensitivity 를 곱해서 감도를 설정하고 이전 값에 더해두고 minXLook, maxXLook 범위를 벗어나지 않게 하고 camera를 가지고 있는 cameraContainer 의 x축으로 상하 회전 시킵니다. 다만 마우스의 y축으로 계산하였기 때문에 상하 반전이 일어나 x 축 회전을 마이너스를 곱하여 반전 시켜주고 
Player를 마우스 의 x 축을 lookSensitivity 곱하여 감도를 설정하고 y축으로 좌우 회전 시킵니다.
IsGrounded 함수에서는 캐릭터의 z,x 축으로 ray를 4번 쏴서 groundLayerMask인 오브젝트와 닿았는지를 확인합니다.

- `Move`와 `CameraLook` 함수를 각각 `FixedUpdate`, `LateUpdate`에서 호출하는 이유에 대해 생각해보세요.
  - Move 함수는 캐릭터의 움직임을 물리엔진을 통해 이동 시키기 때문에 물리적 연산 시에는 FixedUpdate에서 호출해야 합니다.
CameraLook 함수는 캐릭터의 카메라 회전을 물리엔진을 통해 이동 시키지 않기 때문에 LateUpdate에서 호출해야 합니다.
CameraLook를 Update 에서 실행하지 않는 이유는 캐릭터의 위치가 최종적으로 Update함수에서 위치가 확정 되고 카메라를 그 위치에 같이 Camera를 움직이면 서로 같은 위치로 가지만 따로 떨어져서 가는 것 처럼 보여지기 때문에 우선 캐릭터의 위치를 Update에서 확정 후
LateUpdate에서 카메라가 캐릭터를 따라 움직이면 움직이면 자연스럽게 따라오는 것을 구현 할 수 있게 됩니다.

## Q2 분석 문제

- 별도의 UI 스크립트를 만드는 이유에 대해 객체지향적 관점에서 생각해보세요.
  - 여러개의 UI 오브젝트 들을 하나의 스크립트에서 관리하게 되면 UI 스크립트의 목적이 명확하지 않아지고 코드가 복잡해지는 문제가 있습니다.
되도록이면 기능별로 UI 스크립트를 분리하고 관리하는 것이 좋습니다.

- 인터페이스의 특징에 대해 정리해보고 구현된 로직을 분석해보세요.
  - 현재 프로젝트에서 인터페이스를 사용하여 클래스간의 의존도를 낮추어 주는 역할을 하고 있습니다.
따라서 기능별로 클래스를 구현하지 않아도 인터페이스를 통해 추상적으로 로직을 수행 할 수 있습니다.

- 핵심 로직을 분석해보세요. (UI 스크립트 구조, `CampFire`, `DamageIndicator`)
  - UI 스크립트는 부모 UI가 자식 UI를 다른 오브젝트에서 식별 가능한 상태로 정의해주고, 자식 UI에서는 온전히 기능구현에만 사용됩니다.
다만 UIInventory의 경우에는 UIInventory 자체가 하나의 기능으로서 작동하기 때문에 아이템 관리는 기능(함수)들이 UIInventory 에 구현되어 있습니다.
이런 방식은 목적이 명확하기 때문에 좋은 방법이라고 생각합니다.
CampFire 는 Trigger를 통해 IDamageable 인터페이스를 상속받은 오브젝트가 인접해 있을 때, IDamangeable 을 리스트에 담아두고 InvokeRepeating을 통해 일정 시간마다 데미지를 입히는 로직입니다.
DamageIndicator 는 IDamageable 인터페이스를 상속받은 오브젝트가 데미지를 입었을 때, 데미지를 입는 것을 인지할 수 있도록 효과를 표시하는 로직입니다.

## Q3 분석 문제

- `Interaction` 기능의 구조와 핵심 로직을 분석해보세요.
  - Interaction은 LayerMask가 Interactable인 오브젝트 대상으로 상호작용을 할 수 있게 해주는 기능입니다.
내부적으로는 Ray를 일정 시간 주기로 스크린 중앙에 오브젝트가 있는지를 판단하고, 상호작용 가능한 오브젝트라면 화면 중앙에 명시적으로 이름과 설명을 표시해 줍니다.
상호작용 하면 아이템인 경우에는 캐릭터의 인벤토리에 추가하게 됩니다.

- `Inventory` 기능의 구조와 핵심 로직을 분석해보세요.
  - Inventory 의 기능은 여러개의 아이템을 알맞은 저장하고 아이템을 선택 했을때 정보를 표시하며, 아이템 타입이 따라 사용하거나 착용/착용해제, 버리기 등의 기능을 수행하는 구조로 되어 있습니다.
Inventory 의 핵심 로직은 아이템을 관리하는 로직이며, AddItem 함수를 통해 새로운 아이템을 추가하거나 기존 아이템에 누적하여 추가하고
ThrowItem 함수를 통해 플레이어 주변에 아이템을 버리거나 SelectItem 함수를 통해 아이템의 상세정보를 표시해줍니다.
OnUseButton 함수는 사용하기 UI Button에 이벤트로 등록되어 있어 버튼을 클릭하면 아이템을 사용합니다.
OnDropButton 함수는 버리기 UI Button에 이벤트로 등록되어 있어 버튼을 클릭하면 아이템을 버립니다.
OnEquipButton 함수는 착용하기 UI Button에 이벤트로 등록되어 있어 버튼을 클릭하면 아이템을 착용합니다.
OnUnEquipButton 함수는 착용해제 UI Button에 이벤트로 등록되어 있어 버튼을 클릭하면 착용중인 아이템을 착용해제합니다.
