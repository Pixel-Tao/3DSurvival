분석 문제 : 분석한 내용을 직접 작성하고, 강의의 코드를 다시 한번 작성하며 복습해봅시다.

- 입문 주차와 비교해서 입력 받는 방식의 차이와 공통점을 비교해보세요.
입문 주차와 숙련 주차에서 Move와 Look 입력 받는 방식의 공통점은 입력 값에 대해 x,y 좌표만 받는 다는 것입니다.
차이점은 동일한 x,y 좌표를 가지고 캐릭터가 3D 좌표 평면에서 움직이느냐 2D 좌표 평면에서 움직이느냐 차이인데,
3D 인 경우 캐릭터의 진행방향이 위쪽이 아닌 정면을 바라보고 움직여야 하기 때문에 z 축을 방향으로 움직여야합니다.
2D 인 경우 캐릭터의 진행방향이 상하좌우로만 이동하기 때문에 입력 받은 값 그대로 사용하여 캐릭터를 움직여도 무방합니다.

- `CharacterManager`와 `Player`의 역할에 대해 고민해보세요.
현재 프로젝트에서 CharacterManager는 Player와 연관성이 없는 UI와 같은 객체들과의 상호작용을 위해 의존성 높여 주는 역할을 하고 있습니다.
Player는 실제 캐릭터를 조작하고 움직이며 그 외 다른 객체와 상호작용 할 수 있는 역할을 수행 하고 있습니다.

- 핵심 로직을 분석해보세요 (`Move`, `CameraLook`, `IsGrounded`)
Move 함수에서는 입력 받은 key의 x,y 방향 좌표를 받아 캐릭터의 이동 방향을 계산하고 캐릭터의 속도를 곱해주고 y값은 기존 y값과 동일하게 하여 위로 향하지 않게 고정해준 후 구해진 이동 방향을 rigidbody의 velocity에 대입합니다.
CameraLook 함수에서는 마우스 위치의 y 축 값을 lookSensitivity 를 곱해서 감도를 설정하고 이전 값에 더해두고 minXLook, maxXLook 범위를 벗어나지 않게 하고 camera를 가지고 있는 cameraContainer 의 x축으로 상하 회전 시킵니다. 다만 마우스의 y축으로 계산하였기 때문에 상하 반전이 일어나 x 축 회전을 마이너스를 곱하여 반전 시켜주고 
Player를 마우스 의 x 축을 lookSensitivity 곱하여 감도를 설정하고 y축으로 좌우 회전 시킵니다.
IsGrounded 함수에서는 캐릭터의 z,x 축으로 ray를 4번 쏴서 groundLayerMask인 오브젝트와 닿았는지를 확인합니다.

- `Move`와 `CameraLook` 함수를 각각 `FixedUpdate`, `LateUpdate`에서 호출하는 이유에 대해 생각해보세요.
Move 함수는 캐릭터의 움직임을 물리엔진을 통해 이동 시키기 때문에 물리적 연산 시에는 FixedUpdate에서 호출해야 합니다.
CameraLook 함수는 캐릭터의 카메라 회전을 물리엔진을 통해 이동 시키지 않기 때문에 LateUpdate에서 호출해야 합니다.
CameraLook를 Update 에서 실행하지 않는 이유는 캐릭터의 위치가 최종적으로 Update함수에서 위치가 확정 되고 카메라를 그 위치에 같이 Camera를 움직이면 서로 같은 위치로 가지만 따로 떨어져서 가는 것 처럼 보여지기 때문에 우선 캐릭터의 위치를 Update에서 확정 후
LateUpdate에서 카메라가 캐릭터를 따라 움직이면 움직이면 자연스럽게 따라오는 것을 구현 할 수 있게 됩니다.